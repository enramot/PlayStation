#!/usr/bin/env pike
//! This program converts a JSON file to a Sublime language definition file.
//! 
//! run like:
//!
//! user@computer:~$ to-tmlanguage /path/to/json-file
//!
//! The resulting file will be placed in the same directory as the original
//! file. NOTE! The resulting file will be named like 
//! [first-part-of-orgiginal-file.tmLanguage]. So if the input file is named
//! Lang.json the resulting file will be named Lang.tmLanguage.
//!
//! * To generate a UUID give the "key" uuid in the property list file the value
//!   #uuid. The #uuid part will be replaced with a real UUID.
//!
//! * $scopeName in the JSON file will be expanded to the value of the 
//!   "scopeName" key.
//!
//! { "name" : "Lang",
//!   "scopeName" : "source.lang",
//!   "uuid" : "#uuid",
//"   "test" : "some.stuff.$scopeName" 
//! }
//! 
//! Will result in 
//!
//! <dict>
//!   <key>name</key>
//!   <string>Lang</string>
//!   <key>scopeName</key>
//!   <string>source.lang</string>
//!   <key>uuid</key>
//!   <string>f0c5f4ad-3e8a-4add-9ebf-2ce1d5e5262f</string>
//!   <key>test</key>
//!   <string>some.stuff.source.lang</string>
//! </dict>

#ifdef DEVMODE
// If run with: pike -DDEVMODE to-tmlanguage the-file
// a copy of Pike.tmLanguage will be put here.
string config_path = "/home/poppa/.config/sublime-text-2/Packages/User";
#endif

String.Buffer buffer;
function add;
int level = 1;

// Replace < > and with XML entities
#define rep(X) replace((string)(X), ([ "<" : "&lt;", ">" : "&gt;" ]))

// Add opening tag to buffer
#define tag1(X) "\n" + ("  " * level) + "<" + X + ">"

// Add closing tag to buffer
#define tag2(X) "</" + X  + ">"

// Add tag to buffer
#define tag(TYPE,VAL) add(tag1(TYPE), rep((VAL)), tag2(TYPE))

// Append newline and indentation to buffer
#define end() ("\n" + ("  " * level))

// Regexp for removing our own comments in the JSON file
Regexp.PCRE comment_re = Regexp.PCRE("^[ \t]*//-.*$", Regexp.PCRE.OPTION.MULTILINE);

int main(int argc, array(string) argv)
{
  if (argc < 2) {
    werror("Missing sublime Syntax file as argument\n");
    return 1;
  }

  string file = argv[1];

  if (!Stdio.exist(file) || !Stdio.is_file(file)) {
    werror("Argument is not a file!\n");
    return 1;
  }

  buffer = String.Buffer();
  add = buffer->add;

  add("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
      "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" "
      "\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n"
      "<plist version=\"1.0\">");

  string file_content = Stdio.read_file(file);

  // Remove our special comments  
  file_content = comment_re->replace(file_content, "");

  array(string) fcarr = file_content/"\n";
  array(string) newarr = ({});
  array(string) tmparr = ({});

  // Kindly we can have strings over multiple lines. Lets concatenate those
  // strings here so the JSON parser won't get upset.
  foreach (fcarr, string ln) {
    if (!sizeof(ln))
      continue;

    if (ln[-1] == '\\') {
      // Remove the trailing backslash
      ln = String.trim_all_whites( ln[0..sizeof(ln)-2] );
      // Remove the trailing quote
      ln = ln[0..sizeof(ln)-2];

      if (sizeof(tmparr) > 0)
        // Remove the beginning quote
        ln = ln[1..];
      
      tmparr += ({ ln });
    }
    else {
      if (sizeof(tmparr)) {
        ln = String.trim_all_whites(ln);
        tmparr += ({ ln[1..] });
        newarr += ({ tmparr*"" });
        tmparr = ({});
      }
      else
        newarr += ({ ln }); 
    }
  }

  mixed json = Standards.JSON.decode(newarr*"");

  if (json->uuid && json->uuid == "#uuid") {
    json->uuid = (string) Standards.UUID.make_version4();
    file_content = replace(file_content, "#uuid", json->uuid);
    Stdio.write_file(file, file_content);
  }

  encode_xml(json);

  add("\n</plist>");

  string data = buffer->get();

  foreach (json; string key; mixed v) {
    if (stringp(v))
      data = replace(data, "$" + key, v);
  }
  
  string ofname, fname, path;
  path = dirname(file);
  ofname = fname = basename(file);

  if (search(fname, ".") > -1)
    fname = (fname/".")[0];

  fname += ".tmLanguage";

  if (fname == ofname) {
    werror("The input file has the same name as the output file! Please "
           "rename the input file!\n");
    return 1;
  }
  
  path = combine_path(path, fname);

  Stdio.write_file(path, data);
  
#ifdef DEVMODE
  Stdio.write_file(combine_path(config_path, fname), data);
#endif

  return 0;
}

string type_to_string(mixed x)
{
  if (intp(x)) return "int";
  if (arrayp(x)) return "array";
  if (floatp(x)) return "float";
  if (stringp(x)) return "string";
  if (mappingp(x)) return "dict";

  error("Unhandled Pike type: %O\n", x); 
}

mixed encode_xml(mixed in)
{
  string type = type_to_string(in);

  switch (type)
  {
    case "dict":

      add(tag1(type));

      foreach (in; string key; mixed value) {
        level++;
        tag("key", key);
        encode_xml(value);
        level--;
      }

      add(end(), tag2(type));

      break;

    case "array":

      add(tag1(type));

      foreach (in, mixed v) {
        level++;
        encode_xml(v);
        level--;
      }

      add(end(), tag2(type));

      break;

    case "string":
    case "float":
    case "int":

      tag(type, in);

      break;
  }
}

